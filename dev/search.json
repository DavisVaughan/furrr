[{"path":[]},{"path":"https://furrr.futureverse.org/dev/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://furrr.futureverse.org/dev/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://furrr.futureverse.org/dev/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://furrr.futureverse.org/dev/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://furrr.futureverse.org/dev/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement codeofconduct@rstudio.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://furrr.futureverse.org/dev/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://furrr.futureverse.org/dev/CODE_OF_CONDUCT.html","id":"1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://furrr.futureverse.org/dev/CODE_OF_CONDUCT.html","id":"2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://furrr.futureverse.org/dev/CODE_OF_CONDUCT.html","id":"3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://furrr.futureverse.org/dev/CODE_OF_CONDUCT.html","id":"4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://furrr.futureverse.org/dev/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://furrr.futureverse.org/dev/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 Davis Vaughan Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://furrr.futureverse.org/dev/articles/carrier.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Alternative to automatic globals detection","text":"writing production code furrr, might want leave automatic globals detection ensure everything shipped worker correctly. generally works well, always edge cases static code analysis may cause either fail (bad) copy objects workers required (less bad, still great). alternative, can use carrier package Lionel Henry manually isolate dependencies required function. ensures function’s environment contains requested, nothing . Combine furrr_options(globals = FALSE) turn automatic globals detection, end production worthy way use furrr.","code":""},{"path":"https://furrr.futureverse.org/dev/articles/carrier.html","id":"crates","dir":"Articles","previous_headings":"","what":"Crates","title":"Alternative to automatic globals detection","text":"idea behind carrier package function dependencies crate. crate just another function, specialized function environment carries around dependencies required run. create crate, directly wrap call function() crate(). can also specify function crate using anonymous function shorthand ~. must manually namespace package function calls pkg::, crated function runs environment base package loaded. “outside” dependencies require must also manually specified creating crate, otherwise won’t found. can specify dependencies either inlining crate !!, supplying name-value pairs crate(): Crates nice print method, allowing see size crate captured: One downside inlining !! doesn’t show separate element print method: last thing know crates generally required crate new function. “new”, mean function already created beforehand assigned name, prevents crate() assigning correct environment.","code":"crt1 <- crate(function(x) {   stats::var(x) })  crt1(c(1, 5, 3)) #> [1] 4 crt1_anon <- crate(~stats::var(.x))  crt1_anon(c(1, 5, 3)) #> [1] 4 crt2 <- crate(function(x) {   var(x) })  crt2(c(1, 5, 3)) #> Error in var(x): could not find function \"var\" constant <- 1.67  crt3 <- crate(~ .x + constant)  crt3(2:5) #> Error in crt3(2:5): object 'constant' not found crt4 <- crate(function(x) {   x + !!constant })  crt4(2:5) #> [1] 3.67 4.67 5.67 6.67 crt5 <- crate(   constant = constant,   function(x) {     x + constant   } )  crt5(2:5) #> [1] 3.67 4.67 5.67 6.67 crt5 #> <crate> 10.09 kB #> * function: 9.53 kB #> * `constant`: 56 B #> function(x) { #>     x + constant #>   } crt4 #> <crate> 9.61 kB #> * function: 9.16 kB #> function(x) { #>   x + !!constant #> } fn <- function(x) {   x }  crate(fn) #> Error in `crate()`: #> ! The function must be defined inside the `crate()` call"},{"path":"https://furrr.futureverse.org/dev/articles/carrier.html","id":"crates-and-furrr","dir":"Articles","previous_headings":"","what":"Crates and furrr","title":"Alternative to automatic globals detection","text":"Using crated function furrr just like using function, except won’t need rely automatic globals detection (unless globals .x ... need found, somewhat rare). example, crt5() created also captured constant dependency object function’s environment. Since furrr serializes .f alongside environment, dependencies come along free without need auto detect . crate function extra optional arguments, can still pass using furrr: Crates also great way avoid accidentally shipping unneeded dependencies. Common Gotchas article, discuss following example accidentally shipping big object worker, even though isn’t required function . function call extremely fast, significantly slower expected serialize big. One way avoid use carrier crate function, isolating surrounding environment.","code":"crt5 #> <crate> 10.09 kB #> * function: 9.53 kB #> * `constant`: 56 B #> function(x) { #>     x + constant #>   } plan(multisession, workers = 2)  opts <- furrr_options(globals = FALSE)  x <- list(1:10, 11:20)  future_map(x, crt5, .options = opts) #> [[1]] #>  [1]  2.67  3.67  4.67  5.67  6.67  7.67  8.67  9.67 10.67 11.67 #>  #> [[2]] #>  [1] 12.67 13.67 14.67 15.67 16.67 17.67 18.67 19.67 20.67 21.67 median_doubled <- crate(function(x, na.rm = FALSE) {   stats::median(x, na.rm = na.rm) * 2 }) plan(multisession, workers = 2)  opts <- furrr_options(globals = FALSE)  x <- list(c(1, NA, 2), c(4, 5, NA))  future_map_dbl(x, median_doubled, na.rm = TRUE, .options = opts) #> [1] 3 9 my_slow_fn <- function() {   # Massive object - but we don't want it in `.f`   big <- 1:1e8 + 0L      future_map_int(1:5, ~.x) } plan(multisession, workers = 2)  system.time({   my_slow_fn() }) #>    user  system elapsed  #>   0.608   0.647   2.613 my_crated_fn <- function() {   # Massive object - but we don't want it in `.f`   big <- 1:1e8 + 0L      fn <- crate(~.x)   opts <- furrr_options(globals = FALSE)      future_map_int(1:5, fn, .options = opts) } plan(multisession, workers = 2)  system.time({   my_crated_fn() }) #>    user  system elapsed  #>   0.278   0.223   1.010"},{"path":"https://furrr.futureverse.org/dev/articles/chunking.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Chunking input","text":"article discusses furrr “chunks” input default, control manually scheduling chunk_size arguments. Chunking process breaking .x smaller pieces can sent different workers processed parallel. worker gets chunk .x, maps calling .f element. results workers returned main R session chunks processed combined returned future_map(). Chunks determined using internal function furrr called make_chunks(). ’ll expose demonstrate various strategies.","code":"make_chunks <- furrr:::make_chunks"},{"path":"https://furrr.futureverse.org/dev/articles/chunking.html","id":"default-chunking-strategy","dir":"Articles","previous_headings":"","what":"Default chunking strategy","title":"Chunking input","text":"default chunking strategy furrr place 1 chunk worker. splitting .x evenly possible across number workers. simplest strategy, usually works fairly well.","code":"# Elements 1:6 go to worker 1 # Elements 7:12 go to worker 2 make_chunks(n_x = 12, n_workers = 2) #> [[1]] #> [1] 1 2 3 4 5 6 #>  #> [[2]] #> [1]  7  8  9 10 11 12  # Element 1 goes to worker 1 # Element 2 goes to worker 2 make_chunks(n_x = 2, n_workers = 4) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2  # Chunks aren't always evenly distributed make_chunks(n_x = 10, n_workers = 4) #> [[1]] #> [1] 1 2 3 #>  #> [[2]] #> [1] 4 5 #>  #> [[3]] #> [1] 6 7 #>  #> [[4]] #> [1]  8  9 10"},{"path":"https://furrr.futureverse.org/dev/articles/chunking.html","id":"tweaking-the-number-of-chunks-per-worker","dir":"Articles","previous_headings":"","what":"Tweaking the number of chunks per worker","title":"Chunking input","text":"default strategy comes using furrr_options(scheduling = 1). scheduling argument allows alter average number chunks per worker. example, increasing scheduling = 2L makes furrr operate “dynamically”. 12 elements 2 workers, : Send elements 1:3 worker 1 Send elements 4:6 worker 2 Wait next available worker Send elements 7:9 worker Wait next available worker Send elements 10:12 worker first two batches work sent , furrr wait next available worker send elements 7:9 . worker 2 finishes worker 1 (entirely possible elements processing require less time) used work elements 7:9. Contrast setting scheduling = 1L example, results just 2 chunks, 1:6 7:12. first chunk sent worker 1 second worker 2. element 4 happens take extremely long amount time, might waiting worker 1 finish long worker 2 . case, dynamic scheduling might help overall performance. However, result serialization calls, can degrade performance. end, choosing right strategy requires knowledge function trying parallelize. extreme end scheduling set Inf, creates n_x chunks (1 chunk per element .x).","code":"make_chunks(n_x = 12, n_workers = 2, scheduling = 2L) #> [[1]] #> [1] 1 2 3 #>  #> [[2]] #> [1] 4 5 6 #>  #> [[3]] #> [1] 7 8 9 #>  #> [[4]] #> [1] 10 11 12 make_chunks(n_x = 5, n_workers = 2, scheduling = Inf) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] 5"},{"path":"https://furrr.futureverse.org/dev/articles/chunking.html","id":"tweaking-the-number-of-elements-per-chunk","dir":"Articles","previous_headings":"","what":"Tweaking the number of elements per chunk","title":"Chunking input","text":"Instead using scheduling, can also modify chunking strategy using chunk_size, controls average number elements per chunk. used place scheduling, , set, override scheduling value. example, specifying chunk_size 4 create 3 chunks size 4 send 2 workers. Computing chunks using chunk_size independent number workers. Inf chunk_size requests elements processed single chunk.","code":"make_chunks(n_x = 12, n_workers = 2, chunk_size = 4) #> [[1]] #> [1] 1 2 3 4 #>  #> [[2]] #> [1] 5 6 7 8 #>  #> [[3]] #> [1]  9 10 11 12 make_chunks(n_x = 5, n_workers = 3, chunk_size = Inf) #> [[1]] #> [1] 1 2 3 4 5"},{"path":"https://furrr.futureverse.org/dev/articles/gotchas.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Common gotchas","text":"article lists common gotchas working furrr.","code":""},{"path":"https://furrr.futureverse.org/dev/articles/gotchas.html","id":"non-standard-evaluation-of-arguments","dir":"Articles","previous_headings":"","what":"Non-standard evaluation of arguments","title":"Common gotchas","text":"One difference purrr furrr evaluate arguments passed ... functions future_map(). happen can serialized shipped worker sessions. guaranteed arguments evaluated , prevents “lazy” behavior possible purrr. example: map() delays evaluation long possible, pets evaluated context data frame exists, can detect pets column data frame. future_map() evaluate argument early, pets evaluated context data frame doesn’t exist, get error. One alternative pass column character string, use .data pronoun retrieve column.","code":"filter_for_dogs <- function(data, col) {   filter(data, {{ col }} == \"dog\") }  df1 <- tibble(   pets = c(\"dog\", \"cat\"),   names = c(\"Floofy\", \"Buttercup\") )  df2 <- tibble(   pets = c(\"horse\", \"dog\", \"mouse\"),   names = c(\"Stalone\", \"Fido\", \"Cheesy\") )  dfs <- list(df1, df2) map(dfs, filter_for_dogs, col = pets) #> [[1]] #> # A tibble: 1 × 2 #>   pets  names  #>   <chr> <chr>  #> 1 dog   Floofy #>  #> [[2]] #> # A tibble: 1 × 2 #>   pets  names #>   <chr> <chr> #> 1 dog   Fido future_map(dfs, filter_for_dogs, col = pets) #> Error in get_globals_and_packages(options$globals, options$packages, map_fn, : object 'pets' not found filter_for_dogs2 <- function(data, col) {   filter(data, .data[[col]] == \"dog\") } future_map(dfs, filter_for_dogs2, col = \"pets\") #> [[1]] #> # A tibble: 1 × 2 #>   pets  names  #>   <chr> <chr>  #> 1 dog   Floofy #>  #> [[2]] #> # A tibble: 1 × 2 #>   pets  names #>   <chr> <chr> #> 1 dog   Fido"},{"path":"https://furrr.futureverse.org/dev/articles/gotchas.html","id":"argument-evaluation","dir":"Articles","previous_headings":"","what":"Argument evaluation","title":"Common gotchas","text":"purrr furrr, difference passing arguments ... specifying arguments anonymous function directly. Arguments passed ... evaluated just . want argument evaluated iteration, ’ll need put inside anonymous function. example: case furrr purrr, common question. Note furrr case, evaluate argument anonymous function evaluated worker . means control reproducibility, pass options argument specified seed.","code":"x <- rep(0, 3)  plus <- function(x, y) x + y set.seed(123)  map_dbl(x, plus, runif(1)) #> [1] 0.2875775 0.2875775 0.2875775  map_dbl(x, ~ plus(.x, runif(1))) #> [1] 0.7883051 0.4089769 0.8830174 plan(multisession, workers = 2)  options <- furrr_options(seed = 123)  future_map_dbl(x, plus, runif(1)) #> [1] 0.9404673 0.9404673 0.9404673  future_map_dbl(x, ~ plus(.x, runif(1)), .options = options) #> [1] 0.1552317 0.4877356 0.5330014  plan(sequential)"},{"path":"https://furrr.futureverse.org/dev/articles/gotchas.html","id":"grouped-data-frames","dir":"Articles","previous_headings":"","what":"Grouped data frames","title":"Common gotchas","text":"common source frustration swapping map() future_map() realizing computation proceeding massively slower map(). One possible reason called future_map() column grouped data frame. example possible following data frame arise naturally nested grouped data frame. ’d like map perform computation element x, might try use future_map_dbl(), ’ll surprised slow can . issue grouped nature data frame prevents furrr good - sharding x column equally sized groups sending workers process parallel. Instead, data frame grouped, group corresponds 1 row data frame, dplyr hands future_map_dbl() 1 element x time operate . future_map_dbl() actually called 100 times ! easy solution just ungroup data frame calling future_map_dbl().","code":"set.seed(123)  df <- tibble(   g = 1:100,   x = replicate(100, runif(10), simplify = FALSE) )  df <- group_by(df, g)  df #> # A tibble: 100 × 2 #> # Groups:   g [100] #>        g x          #>    <int> <list>     #>  1     1 <dbl [10]> #>  2     2 <dbl [10]> #>  3     3 <dbl [10]> #>  4     4 <dbl [10]> #>  5     5 <dbl [10]> #>  6     6 <dbl [10]> #>  7     7 <dbl [10]> #>  8     8 <dbl [10]> #>  9     9 <dbl [10]> #> 10    10 <dbl [10]> #> # … with 90 more rows #> # ℹ Use `print(n = ...)` to see more rows plan(multisession, workers = 2)  t1 <- proc.time()  df %>%   mutate(y = future_map_dbl(x, mean)) #> # A tibble: 100 × 3 #> # Groups:   g [100] #>        g x              y #>    <int> <list>     <dbl> #>  1     1 <dbl [10]> 0.578 #>  2     2 <dbl [10]> 0.523 #>  3     3 <dbl [10]> 0.616 #>  4     4 <dbl [10]> 0.538 #>  5     5 <dbl [10]> 0.345 #>  6     6 <dbl [10]> 0.433 #>  7     7 <dbl [10]> 0.554 #>  8     8 <dbl [10]> 0.425 #>  9     9 <dbl [10]> 0.559 #> 10    10 <dbl [10]> 0.415 #> # … with 90 more rows #> # ℹ Use `print(n = ...)` to see more rows  t2 <- proc.time()  plan(sequential)  t2 - t1 #>    user  system elapsed  #>   1.359   0.035   4.282 plan(multisession, workers = 2)  t1 <- proc.time()  df %>%   ungroup() %>%   mutate(y = future_map_dbl(x, mean)) #> # A tibble: 100 × 3 #>        g x              y #>    <int> <list>     <dbl> #>  1     1 <dbl [10]> 0.578 #>  2     2 <dbl [10]> 0.523 #>  3     3 <dbl [10]> 0.616 #>  4     4 <dbl [10]> 0.538 #>  5     5 <dbl [10]> 0.345 #>  6     6 <dbl [10]> 0.433 #>  7     7 <dbl [10]> 0.554 #>  8     8 <dbl [10]> 0.425 #>  9     9 <dbl [10]> 0.559 #> 10    10 <dbl [10]> 0.415 #> # … with 90 more rows #> # ℹ Use `print(n = ...)` to see more rows  t2 <- proc.time()  plan(sequential)  t2 - t1 #>    user  system elapsed  #>   0.058   0.000   0.550"},{"path":"https://furrr.futureverse.org/dev/articles/gotchas.html","id":"graphics-devices","dir":"Articles","previous_headings":"","what":"Graphics devices","title":"Common gotchas","text":"use multicore plan, shouldn’t try generate save plots graphics devices, includes using ggplot2. can cause X11 fatal error can’t safely run forked environment, can crash R session. Instead, use plan(multisession) avoid issues. See issue details.","code":""},{"path":"https://furrr.futureverse.org/dev/articles/gotchas.html","id":"package-development","dir":"Articles","previous_headings":"","what":"Package development","title":"Common gotchas","text":"developing package imports calls functions furrr, ’ll likely using devtools::load_all() part development process. likely unless install package, might run issues functions internal package aren’t exported workers (see issue #95). Specifically, following, probably issues: package yet installed machine, old version installed. call devtools::load_all(). set multisession multicore strategy furrr. call future_map() furrr function inside package, .f contains function specific package. example, underlying globals package likely think function called .f part package installed machine, won’t try export workers. Instead, just try load package worker get access function. Since package hasn’t installed machine yet (load_all() just mocks fake installation) workers fail attach . solution just install package devtools::install() using RStudio Build pane, restart R. Make sure re-install whenever make additional changes package.","code":""},{"path":"https://furrr.futureverse.org/dev/articles/gotchas.html","id":"function-environments-and-large-objects","dir":"Articles","previous_headings":"","what":"Function environments and large objects","title":"Common gotchas","text":"future_map() friends called within another function, extremely careful .f function pass . function future_map() called contains large object, possible object get captured function environment .f exported worker, even never used function . example, big captured function environment anonymous function ~.x exported. Note problem isn’t big identified global furrr. can even prove workers using get() look object called \"big\" current surrounding environments. ’ll use smaller object , concept . One solution create .f somewhere won’t capture massive object surrounding environment. example: lexical scoping used find fn, also pass argument my_not_so_slow_fn(). works naturally package development environment, fn() just helper function package can call anywhere else package without issue. , can prove object doesn’t make onto workers: Another alternative help issue use carrier package crate function. learn , see article entitled Alternative automatic globals detection.","code":"my_fast_fn <- function() {   future_map(1:5, ~.x) }  my_slow_fn <- function() {   # Massive object - but we don't want it in `.f`   big <- 1:1e8 + 0L      future_map(1:5, ~.x) } plan(multisession, workers = 2)  system.time(   my_fast_fn() ) #>    user  system elapsed  #>   0.029   0.000   0.555  system.time(   my_slow_fn() ) #>    user  system elapsed  #>   0.616   0.686   2.263  plan(sequential) plan(multisession, workers = 2)  my_slow_fn2 <- function() {   big <- \"can you find me?\"      future_map(1:2, ~get(\"big\")) }  my_slow_fn2() #> [[1]] #> [1] \"can you find me?\" #>  #> [[2]] #> [1] \"can you find me?\"  plan(sequential) fn <- function(x) {   x }  my_not_so_slow_fn <- function() {   big <- 1:1e8 + 0L      future_map(1:5, fn) }  plan(multisession, workers = 2)  system.time(   my_not_so_slow_fn() ) #>    user  system elapsed  #>   0.308   0.224   1.049  plan(sequential) plan(multisession, workers = 2)  fn2 <- function(x) {   # does an object called `\"big\"` exist anywhere we can find it?   exists(\"big\") }  my_not_so_slow_fn2 <- function() {   big <- \"can you find me?\"      future_map(1:2, fn2) }  my_not_so_slow_fn2() #> [[1]] #> [1] FALSE #>  #> [[2]] #> [1] FALSE  plan(sequential)"},{"path":"https://furrr.futureverse.org/dev/articles/progress.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Progress notifications with progressr","text":"Everyone loves progress bars. even true running long computations parallel, ’d really like approximation job going finish. furrr currently progress bar usage .progress = TRUE, future deprecated favor generic robust progress updates progressr package. ’ve never heard progressr, ’d encourage read introduction vignette. One neat things isn’t limited just progress bars. progressr really framework progress updates, can relayed user using progress bar, beeping noise computer, even email slack notifications. works sequential, multisession, cluster futures, means even works remote connections. currently doesn’t work multicore, likely change. begin, please aware progressr still new experimental package. doubt many breaking changes , new patterns signaling progress updates likely emerge enough people start using . ’ve used furrr’s .progress argument, solutions presented might feel bit clunkier . progressr gets usage, hopefully simpler unified way presenting progress information emerge can used map-reduce future packages (furrr, future.apply, doFuture). progressr used varies slightly depending whether package developer interactive user. two main functions used: progressor(), makes object can signal progress updates, with_progress(), listens progress signals. Generally, progressor() used package developer inside function like produce progress updates. user calls function, won’t get progress notifications unless wrap function call with_progress(). Additionally, user complete control progress updates displayed use progress handler. progressr, start handler_*() tell progressr display progress update. separation developer API user API important, can summarized : p <- progressor() making progress signalers p() signaling unit progress with_progress() listening progress signals handler_*() displaying caught progress signals","code":""},{"path":"https://furrr.futureverse.org/dev/articles/progress.html","id":"package-developers","dir":"Articles","previous_headings":"","what":"Package developers","title":"Progress notifications with progressr","text":"package developer using furrr progressr, function package calls future_map() first use p <- progressor() create progress object, call p() within .f signal progress update iteration map. example, following function iterates list, x, calling sum() element list. iteration, send progress update. ’ve also introduced bit delay otherwise run extremely fast. user’s side, simply calling my_pkg_fun() won’t display anything: However, user wraps with_progress(), notifications displayed. default use handler_txtprogressbar(), creates progress bar utils::txtProgressBar(). mentioned , user controls display progress updates. can change different handler locally providing argument with_progress(handlers = ), can use handlers() set globally. can even use multiple handlers. example, handlers(handler_progress, handler_beepr) can used generate progress bar progress package generate beeps beepr package.","code":"my_pkg_fn <- function(x) {   p <- progressor(steps = length(x))      future_map(x, ~{     p()     Sys.sleep(.2)     sum(.x)   }) } plan(multisession, workers = 2)  set.seed(123)  x <- replicate(n = 10, runif(20), simplify = FALSE) # No notifications result <- my_pkg_fn(x) with_progress({   result <- my_pkg_fn(x) }) #> |===============================                                     |  30%"},{"path":"https://furrr.futureverse.org/dev/articles/progress.html","id":"interactive-usage","dir":"Articles","previous_headings":"","what":"Interactive usage","title":"Progress notifications with progressr","text":"writing data analysis scripts use furrr progressr, separation developer user APIs quite clear since ’ll need generate progress objects progressor(), create function signals progress calling p(), call with_progress(). easiest show example: Currently, with_progress() doesn’t return value expression evaluates, assign result result <-. likely change. Rather writing anonymous function, might want wrap logic .f real function. easiest way right now extra argument p can pass . important thing p <- progressor() called inside with_progress(). generally can’t create progressor object outside with_progress() call. example, doesn’t work:","code":"plan(multisession, workers = 2)  with_progress({   p <- progressor(steps = length(x))      result <- future_map(x, ~{     p()     Sys.sleep(.2)     sum(.x)   }) }) #> |=====================                                               |  20% plan(multisession, workers = 2)  fn <- function(x, p) {   p()   Sys.sleep(.2)   sum(x) }  with_progress({   p <- progressor(steps = length(x))   result <- future_map(x, fn, p = p) }) p <- progressor(steps = length(x))  with_progress({   result <- future_map(x, fn, p = p) }) #> Error in error(\"length(timestamp) == 0L\") :  #>   .validate_internal_state(‘handler(type=update) ... end’): length(timestamp) #> == 0L #> Error in error(\"length(timestamp) == 0L\") :  #>   .validate_internal_state(‘reporter_args() ... begin’): length(timestamp) == #> 0L"},{"path":"https://furrr.futureverse.org/dev/articles/progress.html","id":"with-dplyr","dir":"Articles","previous_headings":"Interactive usage","what":"With dplyr","title":"Progress notifications with progressr","text":"with_progress() doesn’t return value expr right now, current usage progressr, furrr, dplyr far perfect. way use together currently wrap entire dplyr pipeline with_progress(). can create progressor, p, top expression, call future_map() mutate(): can wrap model_fn() another function creates p calls future_map() : additional constraint (now), with_progress() respect progress updates first progressor object signals one. means first call model_mapper() signal updates, second won’t. However, know going something like can use first approach create progressor object twice number rows data frame, pass calls future_map(). state maintained future_map() calls end one long progress bar.","code":"cars <- mtcars %>%   group_by(carb) %>%   group_nest()  model_fn <- function(data, p) {   Sys.sleep(.5)   mod <- lm(mpg ~ cyl + disp, data = data)   out <- mod$coef      p()      out } plan(multisession, workers = 2)  with_progress({   p <- progressor(steps = nrow(cars))      cars2 <- cars %>%     mutate(mod = future_map(data, model_fn, p = p)) }) #> |================================================                    |  67% plan(multisession, workers = 2)  model_mapper <- function(data) {   p <- progressor(steps = length(data))   future_map(data, model_fn, p = p) }  with_progress({   cars2 <- cars %>%     mutate(mod = model_mapper(data)) }) #> |================================================                    |  67% with_progress({   cars2 <- cars %>%     mutate(       mod1 = model_mapper(data),       mod2 = model_mapper(data)     ) }) #> |================================================                    |  67%  # ^ Note, we don't get a second progress bar plan(multisession, workers = 2)  with_progress({   p <- progressor(steps = nrow(cars) * 2)      cars2 <- cars %>%     mutate(       mod1 = future_map(data, model_fn, p = p),       mod2 = future_map(data, model_fn, p = p)     ) }) #> |===================================                                 |  50%"},{"path":"https://furrr.futureverse.org/dev/articles/progress.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Progress notifications with progressr","text":"progressr represents exciting move towards unified framework progress notifications R, still early development cycle needs usage feedback settle best API. future, plan furrr become tightly integrated progressr much easier.","code":""},{"path":"https://furrr.futureverse.org/dev/articles/remote-connections.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Remote connections","text":"point, might need go beyond local computer increased performance scalability. Luckily, furrr depends future framework, still possible accomplish furrr. vignette, learn scale furrr AWS EC2 instances two ways: Running code remotely single EC2 instance Running code parallel multiple EC2 instances","code":"library(furrr) library(purrr) library(dplyr)"},{"path":"https://furrr.futureverse.org/dev/articles/remote-connections.html","id":"aws-ec2-what","dir":"Articles","previous_headings":"","what":"AWS EC2? What?","title":"Remote connections","text":"know exactly AWS EC2 , AMIs , feel free skip section! EC2 Amazon’s Elastic Compute Cloud service. way people like essentially rent computer (multiple) cloud variable amount time. computer can incredibly powerful, really weak (cheap!). can run Linux Windows. furrr, run code EC2 “instances” pre-loaded R. get instance pre-loaded R? Great question. use AMI. AMIs “Amazon Machine Images”, words, custom computer already software loaded onto , rather one starts nothing. kind soul, Louis Aslett, keeps --date RStudio AMIs website. use instance. point, encourage look elsewhere exactly set AWS instance based AMI. blog post dedicated , located website blog.davisvaughan.com.","code":""},{"path":"https://furrr.futureverse.org/dev/articles/remote-connections.html","id":"running-code-remotely-on-a-single-ec2-instance","dir":"Articles","previous_headings":"","what":"Running code remotely on a single EC2 instance","title":"Remote connections","text":"Imagine models going take long time run, ’d rather run laptop. Ideally, ’d able test locally, ’d like run powerful EC2 instance cloud. ’s ’ll learn . example won’t actually run models parallel. Instead, focused sending data single EC2 instance can run models sequentially. next example one go one step work parallel multiple EC2 instances.","code":""},{"path":"https://furrr.futureverse.org/dev/articles/remote-connections.html","id":"modeling-code","dir":"Articles","previous_headings":"Running code remotely on a single EC2 instance","what":"Modeling code","title":"Remote connections","text":"First, need code run want run instance. simplicity, say want run 3 separate linear models mtcars, split gear. furrr, can run parallel locally using following: Note faster sequential code, just demonstrate one might run models parallel.","code":"by_gear <- mtcars %>%   group_split(gear)   models <- map(by_gear, ~lm(mpg ~ cyl + hp + wt, data = .))  models #> [[1]] #>  #> Call: #> lm(formula = mpg ~ cyl + hp + wt, data = .) #>  #> Coefficients: #> (Intercept)          cyl           hp           wt   #>    30.48956     -0.31883     -0.02326     -2.03083   #>  #>  #> [[2]] #>  #> Call: #> lm(formula = mpg ~ cyl + hp + wt, data = .) #>  #> Coefficients: #> (Intercept)          cyl           hp           wt   #>    43.69353      0.05647     -0.12331     -3.20537   #>  #>  #> [[3]] #>  #> Call: #> lm(formula = mpg ~ cyl + hp + wt, data = .) #>  #> Coefficients: #> (Intercept)          cyl           hp           wt   #>    45.29099     -2.03268      0.02655     -6.42290 plan(multisession, workers = 2)  models <- future_map(by_gear, ~lm(mpg ~ cyl + hp + wt, data = .))  models #> [[1]] #>  #> Call: #> lm(formula = mpg ~ cyl + hp + wt, data = .) #>  #> Coefficients: #> (Intercept)          cyl           hp           wt   #>    30.48956     -0.31883     -0.02326     -2.03083   #>  #>  #> [[2]] #>  #> Call: #> lm(formula = mpg ~ cyl + hp + wt, data = .) #>  #> Coefficients: #> (Intercept)          cyl           hp           wt   #>    43.69353      0.05647     -0.12331     -3.20537   #>  #>  #> [[3]] #>  #> Call: #> lm(formula = mpg ~ cyl + hp + wt, data = .) #>  #> Coefficients: #> (Intercept)          cyl           hp           wt   #>    45.29099     -2.03268      0.02655     -6.42290"},{"path":"https://furrr.futureverse.org/dev/articles/remote-connections.html","id":"connecting-to-an-ec2-instance","dir":"Articles","previous_headings":"Running code remotely on a single EC2 instance","what":"Connecting to an EC2 instance","title":"Remote connections","text":"Now, models took hours run? Maybe ’d want run different powerful computer, results returned back local R session. case, go start favorite AWS EC2 instance, pre-loaded R, come back ’ve finished. , ’ll need : Get Public IP EC2 instance. located Instances section EC2 console. Specifically IPv4 Public IP instance. Make sure Security Group allows SSH access either Anywhere IP. Find path .pem file used connect EC2 instance. created created EC2 instance, hopefully know saved ! hand, next step use future::makeClusterPSOCK() connect instance. Traditionally, one use parallel::makePSOCKcluster() connect, future version additional helpful arguments allow us add extra options connecting worker. connection successful, code start outputting package installation messages local console. Let’s step little. workers - public ip addresses workers want connect . multiple, can list . user - used RStudio AMI, always \"ubuntu\". rshopts - options run command line local computer connecting instance ssh. StrictHostKeyChecking=- required default connecting AWS instance first time asked want “continue connecting” authenticity AWS instance can’t verified. Setting option means won’t answer question. IdentitiesOnly=yes - necessarily required, specifies want connect using identity supply -, ends .pem file. rscript_args - helpful argument allows specify R code run command line executable Rscript called worker. Essentially, allows run “start code” worker. case, used create package paths ubuntu user install packages required work furrr. dryrun - already set FALSE default, ’s useful point argument setting TRUE allows verify code run worker correct.","code":"# A t2.micro AWS instance # Created from http://www.louisaslett.com/RStudio_AMI/ public_ip <- \"34.230.28.118\"  # This is where my pem file lives (password file to connect). ssh_private_key_file <- \"path/to/file.pem\" connect_to_ec2 <- function(public_ip, ssh_private_key_file) {   makeClusterPSOCK(          # Public IP number of EC2 instance     workers = public_ip,          # User name (always 'ubuntu')     user = \"ubuntu\",          # Use private SSH key registered with AWS     rshopts = c(       \"-o\", \"StrictHostKeyChecking=no\",       \"-o\", \"IdentitiesOnly=yes\",       \"-i\", ssh_private_key_file     ),          rscript_args = c(       # Set up .libPaths() for the 'ubuntu' user       \"-e\", shQuote(paste0(         \"local({\",         \"p <- Sys.getenv('R_LIBS_USER'); \",         \"dir.create(p, recursive = TRUE, showWarnings = FALSE); \",         \".libPaths(p)\",         \"})\"       )),       # Install furrr       \"-e\", shQuote(\"install.packages('furrr')\")     ),          # Switch this to TRUE to see the code that is run on the workers without     # making the connection     dryrun = FALSE   ) }  cl <- connect_to_ec2(public_ip, ssh_private_key_file)  cl #> Socket cluster with 1 nodes where 1 node is on host ‘34.230.28.118’ (R version 3.6.0 (2019-04-26), platform x86_64-pc-linux-gnu)"},{"path":"https://furrr.futureverse.org/dev/articles/remote-connections.html","id":"running-the-code","dir":"Articles","previous_headings":"Running code remotely on a single EC2 instance","what":"Running the code","title":"Remote connections","text":"Now connection EC2 instance loaded R, ’ll need tell future furrr use . Since already cluster object, change plan() use cluster. Rather using multisession plan, use cluster plan extra argument, workers, set cluster connection (see ?future::cluster info). ’s ! code just ran EC2 instance! good practice always disconnect cluster finished working . Don’t forget terminate instance well!","code":"plan(cluster, workers = cl)  models <- future_map(by_gear, ~lm(mpg ~ cyl + hp + wt, data = .))  models #> [[1]] #>  #> Call: #> lm(formula = mpg ~ cyl + hp + wt, data = .) #>  #> Coefficients: #> (Intercept)          cyl           hp           wt   #>    30.48956     -0.31883     -0.02326     -2.03083   #>  #>  #> [[2]] #>  #> Call: #> lm(formula = mpg ~ cyl + hp + wt, data = .) #>  #> Coefficients: #> (Intercept)          cyl           hp           wt   #>    43.69353      0.05647     -0.12331     -3.20537   #>  #>  #> [[3]] #>  #> Call: #> lm(formula = mpg ~ cyl + hp + wt, data = .) #>  #> Coefficients: #> (Intercept)          cyl           hp           wt   #>    45.29099     -2.03268      0.02655     -6.42290 # Revert back to a sequential plan plan(sequential)  parallel::stopCluster(cl)"},{"path":"https://furrr.futureverse.org/dev/articles/remote-connections.html","id":"running-code-in-parallel-on-each-ec2-instance","dir":"Articles","previous_headings":"","what":"Running code in parallel on each EC2 instance","title":"Remote connections","text":"Let’s crank notch. previous example, code run sequentially single EC2 instance. multiple EC2 instances, instances multiple cores use? maximum efficiency, ’d want : First, parallelize across EC2 instances. , parallelize across cores EC2 instance. concrete example 2 t2.xlarge instances, 4 physical cores. Technically means 8 logical cores due hyperthreading, rarely see actual benefits just using maximum number physical cores (exception might hitting API, time spent waiting respond). future world, dubbed “future topology”. entire vignette can find .","code":""},{"path":"https://furrr.futureverse.org/dev/articles/remote-connections.html","id":"connecting-to-multiple-ec2-instances","dir":"Articles","previous_headings":"Running code in parallel on each EC2 instance","what":"Connecting to multiple EC2 instances","title":"Remote connections","text":", just like , start EC2 instances (Make sure check EC2 instance type reference see many virtual cores (vCPUs) one ). launch multiple, clicking AMI want use Louis’s page, “Configure Instance Details” change “Number instances” box whatever require. might also consider changing Purchasing option “Request Spot instances” cheaper instances don’t mind possibility Amazon take instance away temporarily time (hasn’t ever happened ). Note now vector public ip addresses. Otherwise, code remains make connection!","code":"# Two t2.xlarge AWS instances # Created from http://www.louisaslett.com/RStudio_AMI/ public_ip <- c(\"54.157.169.96\", \"18.210.19.243\")  # This is where my pem file lives (password file to connect). ssh_private_key_file <- \"path/to/file.pem\" cl_multi <- connect_to_ec2(public_ip, ssh_private_key_file)  cl_multi #> Socket cluster with 2 nodes where 1 node is on host ‘18.210.19.243’ (R version 3.6.0 (2019-04-26), platform x86_64-pc-linux-gnu), 1 node is on host ‘54.157.169.96’ (R version 3.6.0 (2019-04-26), platform x86_64-pc-linux-gnu)"},{"path":"https://furrr.futureverse.org/dev/articles/remote-connections.html","id":"running-multi-level-parallel-code","dir":"Articles","previous_headings":"Running code in parallel on each EC2 instance","what":"Running multi-level parallel code","title":"Remote connections","text":"Now fun part. tell future first distribute code 2 instances, run parallel instance? pass list plans plan(), also option tweak() plan individually (required set workers argument!). know working? Let’s try something require fixed amount time run locally, try parallel. just going wait 2 seconds iteration, return instance core using. total take 16 seconds. Now, parallel cluster. outer future_map() call distributes two instances, inner future_map_chr() call distributes cores instance. take ~2 seconds, overhead (16 seconds sequentially, split 2 instances, instance 4 physical cores. 2 seconds 8 available cores). bad! extra time due overhead communicating AWS workers, large model relevant. Don’t forget close connection, terminate EC2 instance!","code":"plan(list(   # The outer plan tells future to distribute over the 2 instances   tweak(cluster, workers = cl_multi),       # The inner plan says to run in parallel on each instance   multisession )) t1 <- proc.time()  res <- map(      # Map over the two instances   .x = c(1, 2),       .f = ~ {          outer_idx <- .x          map_chr(              # Each instance has 4 cores we can utilize       .x = c(1, 2, 3, 4),               .f = ~ {         inner_idx <- .x         Sys.sleep(2)         paste0(\"Instance: \", outer_idx, \" and core: \", inner_idx)       }     )        } )  t2 <- proc.time()  res #> [[1]] #> [1] \"Instance: 1 and core: 1\" \"Instance: 1 and core: 2\" \"Instance: 1 and core: 3\" #> \"Instance: 1 and core: 4\" #>  #> [[2]] #> [1] \"Instance: 2 and core: 1\" \"Instance: 2 and core: 2\" \"Instance: 2 and core: 3\" #> \"Instance: 2 and core: 4\" t2 - t1 #>   user  system elapsed  #>  0.055   0.051  16.022 t1 <- proc.time()  res <- future_map(      # Map over the two instances   .x = c(1, 2),       .f = ~{          outer_idx <- .x          future_map_chr(              # Each instance has 4 cores we can utilize       .x = c(1, 2, 3, 4),               .f = ~{         inner_idx <- .x         Sys.sleep(2)         paste0(\"Instance: \", outer_idx, \" and core: \", inner_idx)       }     )        } )  t2 <- proc.time() t2 - t1 #>   user  system elapsed  #>  0.075   0.018   2.728 plan(sequential)  parallel::stopCluster(cl_multi)"},{"path":"https://furrr.futureverse.org/dev/articles/remote-connections.html","id":"conclusion","dir":"Articles","previous_headings":"Running code in parallel on each EC2 instance","what":"Conclusion","title":"Remote connections","text":"vignette, learned distribute code AWS EC2 instances, run code parallel instance using future furrr. Note code used can also used run code platforms Google Cloud Compute, remote clusters. just figure correct way connect clusters. Additionally, connection place just run basic future() commands distribute code well. added benefit locking computer request result value().","code":""},{"path":"https://furrr.futureverse.org/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Davis Vaughan. Author, maintainer. Matt Dancho. Author. RStudio. Copyright holder, funder.","code":""},{"path":"https://furrr.futureverse.org/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Vaughan D, Dancho M (2022). furrr: Apply Mapping Functions Parallel using Futures. https://github.com/DavisVaughan/furrr, https://furrr.futureverse.org/.","code":"@Manual{,   title = {furrr: Apply Mapping Functions in Parallel using Futures},   author = {Davis Vaughan and Matt Dancho},   year = {2022},   note = {https://github.com/DavisVaughan/furrr, https://furrr.futureverse.org/}, }"},{"path":[]},{"path":"https://furrr.futureverse.org/dev/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Apply Mapping Functions in Parallel using Futures","text":"goal furrr combine purrr’s family mapping functions future’s parallel processing capabilities. result near drop replacements purrr functions map() map2_dbl(), can replaced furrr equivalents future_map() future_map2_dbl() map parallel. code draws heavily implementations purrr future.apply package possible without either .","code":""},{"path":"https://furrr.futureverse.org/dev/index.html","id":"what-has-been-implemented","dir":"","previous_headings":"","what":"What has been implemented?","title":"Apply Mapping Functions in Parallel using Futures","text":"Every variant following functions implemented: map() map2() pmap() walk() imap() modify() includes atomic variants like map_dbl() future_map_dbl() predicate variants like map_at() future_map_at().","code":""},{"path":"https://furrr.futureverse.org/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Apply Mapping Functions in Parallel using Futures","text":"can install released version furrr CRAN : development version GitHub :","code":"install.packages(\"furrr\") # install.packages(\"remotes\") remotes::install_github(\"DavisVaughan/furrr\")"},{"path":"https://furrr.futureverse.org/dev/index.html","id":"learning","dir":"","previous_headings":"","what":"Learning","title":"Apply Mapping Functions in Parallel using Futures","text":"easiest way learn furrr browse website. particular, function reference page can useful get general overview functions package, following vignettes deep dives various parts furrr: Common gotchas Learn furrr “chunks” input carrier - alternative automatic globals detection Progress notifications progressr Using furrr connections","code":""},{"path":"https://furrr.futureverse.org/dev/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Apply Mapping Functions in Parallel using Futures","text":"furrr designed function identically purrr possible, can immediately familiarity . default backend future (, furrr) sequential one. means code run box, parallel. design future makes incredibly easy change code run parallel. still skeptical, proof running parallel.","code":"library(furrr) library(purrr)  map(c(\"hello\", \"world\"), ~.x) #> [[1]] #> [1] \"hello\" #>  #> [[2]] #> [1] \"world\"  future_map(c(\"hello\", \"world\"), ~.x) #> [[1]] #> [1] \"hello\" #>  #> [[2]] #> [1] \"world\" # Set a \"plan\" for how the code should run. plan(multisession, workers = 2)  # This does run in parallel! future_map(c(\"hello\", \"world\"), ~.x) #> [[1]] #> [1] \"hello\" #>  #> [[2]] #> [1] \"world\" library(tictoc)  # This should take 6 seconds in total running sequentially plan(sequential)  tic() nothingness <- future_map(c(2, 2, 2), ~Sys.sleep(.x)) toc() #> 6.08 sec elapsed # This should take ~2 seconds running in parallel, with a little overhead # in `future_map()` from sending data to the workers. There is generally also # a one time cost from `plan(multisession)` setting up the workers. plan(multisession, workers = 3)  tic() nothingness <- future_map(c(2, 2, 2), ~Sys.sleep(.x)) toc() #> 2.212 sec elapsed"},{"path":"https://furrr.futureverse.org/dev/index.html","id":"data-transfer","dir":"","previous_headings":"","what":"Data transfer","title":"Apply Mapping Functions in Parallel using Futures","text":"’s important remember data passed back forth workers. means whatever performance gain might gotten parallelization can crushed moving large amounts data around. example, moving large data frames workers, running models parallel, returning large model objects back, shuffling data can take large chunk time. Rather returning entire model object, might consider returning performance metric, smaller specific pieces model interested . performance drop can especially prominent using future_pmap() iterate rows return large objects iteration.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/furrr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"furrr: Apply Mapping Functions in Parallel using Futures — furrr-package","title":"furrr: Apply Mapping Functions in Parallel using Futures — furrr-package","text":"Implementations family map() functions 'purrr' can resolved using 'future'-supported backend, e.g. parallel local machine distributed compute cluster.","code":""},{"path":[]},{"path":"https://furrr.futureverse.org/dev/reference/furrr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"furrr: Apply Mapping Functions in Parallel using Futures — furrr-package","text":"Maintainer: Davis Vaughan davis@rstudio.com Authors: Matt Dancho mdancho@business-science.io contributors: RStudio [copyright holder, funder]","code":""},{"path":"https://furrr.futureverse.org/dev/reference/furrr_options.html","id":null,"dir":"Reference","previous_headings":"","what":"Options to fine tune furrr — furrr_options","title":"Options to fine tune furrr — furrr_options","text":"options fine tune furrr functions, future_map(). either used furrr directly, passed future::future().","code":""},{"path":"https://furrr.futureverse.org/dev/reference/furrr_options.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Options to fine tune furrr — furrr_options","text":"","code":"furrr_options(   ...,   stdout = TRUE,   conditions = \"condition\",   globals = TRUE,   packages = NULL,   seed = FALSE,   scheduling = 1,   chunk_size = NULL,   prefix = NULL )"},{"path":"https://furrr.futureverse.org/dev/reference/furrr_options.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Options to fine tune furrr — furrr_options","text":"... dots reserved future extensibility must empty. stdout logical. TRUE, standard output underlying futures relayed soon possible. FALSE, output silenced sinking null device. conditions character string conditions classes relayed. default relay conditions, including messages warnings. Errors always relayed. relay conditions (besides errors), use conditions = character(). selectively ignore specific classes, use conditions = structure(\"condition\", exclude = \"message\"). globals logical, character vector, named list, NULL controlling globals handled. details, see Global variables section . packages character vector, NULL. supplied, specifies packages guaranteed attached R environment future evaluated. seed logical, integer length 1 7, list length(.x) pre-generated random seeds, NULL. details, see Reproducible random number generation (RNG) section . scheduling single integer, logical, Inf. argument controls average number futures (\"chunks\") per worker. 0, single future used process elements .x. 1 TRUE, one future per worker used. 2, worker process two futures (provided enough elements .x). Inf FALSE, one future per element .x used. argument used chunk_size NULL. chunk_size single integer, Inf, NULL. argument controls average number elements per future (\"chunk\"). Inf, elements processed single future. NULL, scheduling used instead determine .x chunked. prefix single character string, NULL. character string, future assigned label {prefix}-{chunk-id}. NULL, labels used.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/furrr_options.html","id":"global-variables","dir":"Reference","previous_headings":"","what":"Global variables","title":"Options to fine tune furrr — furrr_options","text":"globals controls globals identified, similar globals argument future::future(). Since function calls use set globals, furrr gathers globals upfront (), efficient done future independently. TRUE NULL, globals automatically identified gathered. character vector names specified, globals gathered. named list, globals used . cases, .f ... arguments automatically passed globals future created, always needed.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/furrr_options.html","id":"reproducible-random-number-generation-rng-","dir":"Reference","previous_headings":"","what":"Reproducible random number generation (RNG)","title":"Options to fine tune furrr — furrr_options","text":"Unless seed = FALSE, furrr functions guaranteed generate exact sequence random numbers given initial seed / RNG state regardless type futures scheduling (\"chunking\") strategy. Setting seed = NULL equivalent seed = FALSE, except future.rng.onMisuse option consulted potentially monitor future faulty random number usage. See seed argument future::future() details. RNG reproducibility achieved pre-generating random seeds iterations (.x) using L'Ecuyer-CMRG RNG streams. iteration, seeds set calling .f(.x[[]], ...). Note, large length(.x) may introduce large overhead. fixed seed may given integer vector, either full L'Ecuyer-CMRG RNG seed length 7, seed length 1 used generate full L'Ecuyer-CMRG seed. seed = TRUE, .Random.seed returned holds L'Ecuyer-CMRG RNG seed, otherwise one created randomly. seed = NA, L'Ecuyer-CMRG RNG seed randomly created. none function calls .f(.x[[]], ...) use random number generation, seed = FALSE may used. addition , possible specify pre-generated sequence RNG seeds list length(seed) == length(.x) element integer seed can assigned .Random.seed. Use alternative caution. Note .list(seq_along(.x)) valid set .Random.seed values. cases seed = FALSE, furrr function returns, RNG state calling R process guaranteed \"forwarded one step\" RNG state call. true regardless future strategy / scheduling used. done order guarantee R script calling future_map() multiple times numerically reproducible given initial seed.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/furrr_options.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Options to fine tune furrr — furrr_options","text":"","code":"furrr_options() #> <furrr_options>"},{"path":"https://furrr.futureverse.org/dev/reference/future_imap.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function to each element of a vector, and its index via futures — future_imap","title":"Apply a function to each element of a vector, and its index via futures — future_imap","text":"functions work exactly purrr::imap() functions, allow map parallel.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_imap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function to each element of a vector, and its index via futures — future_imap","text":"","code":"future_imap(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_imap_chr(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_imap_dbl(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_imap_int(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_imap_lgl(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_imap_raw(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_imap_dfr(   .x,   .f,   ...,   .id = NULL,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_imap_dfc(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_iwalk(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )"},{"path":"https://furrr.futureverse.org/dev/reference/future_imap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function to each element of a vector, and its index via futures — future_imap","text":".x list atomic vector. .f function, formula, vector (necessarily atomic). function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. character vector, numeric vector, list, converted extractor function. Character vectors index name numeric vectors index position; use list index position name different levels. component present, value .default returned. ... Additional arguments passed mapped function. .options future specific options use workers. must result call furrr_options(). .env_globals environment look globals required .x .... Globals required .f looked function environment .f. .progress single logical. progress bar displayed? works multisession, multicore, multiprocess futures. Note multicore/multisession future falls back sequential, progress bar displayed. Warning: .progress argument deprecated removed future version furrr favor using robust progressr package. .id Either string NULL. string, output contain variable name, storing either name (.x named) index (.x unnamed) input. NULL, default, variable created. applies _dfr variant.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_imap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function to each element of a vector, and its index via futures — future_imap","text":"vector length .x.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_imap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function to each element of a vector, and its index via futures — future_imap","text":"","code":"plan(multisession, workers = 2)  future_imap_chr(sample(10), ~ paste0(.y, \": \", .x)) #>  [1] \"1: 2\"  \"2: 7\"  \"3: 3\"  \"4: 6\"  \"5: 5\"  \"6: 10\" \"7: 1\"  \"8: 4\"  \"9: 8\"  #> [10] \"10: 9\"  # \\dontshow{ # Close open connections for R CMD Check if (!inherits(plan(), \"sequential\")) plan(sequential) # }"},{"path":"https://furrr.futureverse.org/dev/reference/future_invoke_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Invoke functions via futures — future_invoke_map","title":"Invoke functions via futures — future_invoke_map","text":"functions work exactly purrr::invoke_map() functions, allow invoke parallel.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_invoke_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Invoke functions via futures — future_invoke_map","text":"","code":"future_invoke_map(   .f,   .x = list(NULL),   ...,   .env = NULL,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_invoke_map_chr(   .f,   .x = list(NULL),   ...,   .env = NULL,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_invoke_map_dbl(   .f,   .x = list(NULL),   ...,   .env = NULL,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_invoke_map_int(   .f,   .x = list(NULL),   ...,   .env = NULL,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_invoke_map_lgl(   .f,   .x = list(NULL),   ...,   .env = NULL,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_invoke_map_raw(   .f,   .x = list(NULL),   ...,   .env = NULL,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_invoke_map_dfr(   .f,   .x = list(NULL),   ...,   .env = NULL,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_invoke_map_dfc(   .f,   .x = list(NULL),   ...,   .env = NULL,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )"},{"path":"https://furrr.futureverse.org/dev/reference/future_invoke_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Invoke functions via futures — future_invoke_map","text":".f list functions. .x list argument-lists length .f (length 1). default argument, list(NULL), recycled length .f, call function arguments (apart supplied ...). ... Additional arguments passed function. .env Environment .call() evaluate constructed expression. matters pass .f name function rather value, .x symbols objects rather values. .options future specific options use workers. must result call furrr_options(). .env_globals environment look globals required .x .... Globals required .f looked function environment .f. .progress single logical. progress bar displayed? works multisession, multicore, multiprocess futures. Note multicore/multisession future falls back sequential, progress bar displayed. Warning: .progress argument deprecated removed future version furrr favor using robust progressr package.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_invoke_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Invoke functions via futures — future_invoke_map","text":"","code":"plan(multisession, workers = 2)  df <- dplyr::tibble(   f = c(\"runif\", \"rpois\", \"rnorm\"),   params = list(     list(n = 10),     list(n = 5, lambda = 10),     list(n = 10, mean = -3, sd = 10)   ) )  future_invoke_map(df$f, df$params, .options = furrr_options(seed = 123)) #> [[1]] #>  [1] 0.15523168 0.13489836 0.77349355 0.06467378 0.72312291 0.34779719 #>  [7] 0.76720626 0.90894692 0.94261388 0.47246904 #>  #> [[2]] #> [1]  9 10  9  9  8 #>  #> [[3]] #>  [1]  -2.171833 -18.032800 -10.719393  15.365090   9.164918  -4.410979 #>  [7] -10.297802 -15.180494   1.718361  -4.452757 #>   # \\dontshow{ # Close open connections for R CMD Check if (!inherits(plan(), \"sequential\")) plan(sequential) # }"},{"path":"https://furrr.futureverse.org/dev/reference/future_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function to each element of a vector via futures — future_map","title":"Apply a function to each element of a vector via futures — future_map","text":"functions work exactly purrr::map() variants, allow map parallel.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function to each element of a vector via futures — future_map","text":"","code":"future_map(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map_chr(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map_dbl(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map_int(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map_lgl(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map_raw(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map_dfr(   .x,   .f,   ...,   .id = NULL,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map_dfc(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_walk(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )"},{"path":"https://furrr.futureverse.org/dev/reference/future_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function to each element of a vector via futures — future_map","text":".x list atomic vector. .f function, formula, vector (necessarily atomic). function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. character vector, numeric vector, list, converted extractor function. Character vectors index name numeric vectors index position; use list index position name different levels. component present, value .default returned. ... Additional arguments passed mapped function. .options future specific options use workers. must result call furrr_options(). .env_globals environment look globals required .x .... Globals required .f looked function environment .f. .progress single logical. progress bar displayed? works multisession, multicore, multiprocess futures. Note multicore/multisession future falls back sequential, progress bar displayed. Warning: .progress argument deprecated removed future version furrr favor using robust progressr package. .id Either string NULL. string, output contain variable name, storing either name (.x named) index (.x unnamed) input. NULL, default, variable created. applies _dfr variant.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function to each element of a vector via futures — future_map","text":"functions return vector length .x. future_map() returns list future_map_lgl() logical vector future_map_int() integer vector future_map_dbl() double vector future_map_chr() character vector output .f automatically typed upwards, e.g. logical -> integer -> double -> character.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function to each element of a vector via futures — future_map","text":"","code":"library(magrittr) plan(multisession, workers = 2)  1:10 %>%   future_map(rnorm, n = 10, .options = furrr_options(seed = 123)) %>%   future_map_dbl(mean) #>  [1] 1.180279 2.140442 2.909823 3.692207 5.058100 6.653926 7.065630 7.960713 #>  [9] 9.105674 9.766827  # If each element of the output is a data frame, use # `future_map_dfr()` to row-bind them together: mtcars %>%   split(.$cyl) %>%   future_map(~ lm(mpg ~ wt, data = .x)) %>%   future_map_dfr(~ as.data.frame(t(as.matrix(coef(.))))) #>   (Intercept)        wt #> 1    39.57120 -5.647025 #> 2    28.40884 -2.780106 #> 3    23.86803 -2.192438   # You can be explicit about what gets exported to the workers. # To see this, use multisession (not multicore as the forked workers # still have access to this environment) plan(multisession) x <- 1 y <- 2  # This will fail, y is not exported (no black magic occurs) try(future_map(1, ~y, .options = furrr_options(globals = \"x\"))) #> [[1]] #> [1] 2 #>   # y is exported future_map(1, ~y, .options = furrr_options(globals = \"y\")) #> [[1]] #> [1] 2 #>   # \\dontshow{ # Close open connections for R CMD Check if (!inherits(plan(), \"sequential\")) plan(sequential) # }"},{"path":"https://furrr.futureverse.org/dev/reference/future_map2.html","id":null,"dir":"Reference","previous_headings":"","what":"Map over multiple inputs simultaneously via futures — future_map2","title":"Map over multiple inputs simultaneously via futures — future_map2","text":"functions work exactly purrr::map2() variants, allow map parallel. Note \"parallel\" described purrr just saying working multiple inputs, parallel case means can work multiple inputs process parallel well.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_map2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map over multiple inputs simultaneously via futures — future_map2","text":"","code":"future_map2(   .x,   .y,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map2_chr(   .x,   .y,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map2_dbl(   .x,   .y,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map2_int(   .x,   .y,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map2_lgl(   .x,   .y,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map2_raw(   .x,   .y,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map2_dfr(   .x,   .y,   .f,   ...,   .id = NULL,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map2_dfc(   .x,   .y,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_pmap(   .l,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_pmap_chr(   .l,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_pmap_dbl(   .l,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_pmap_int(   .l,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_pmap_lgl(   .l,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_pmap_raw(   .l,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_pmap_dfr(   .l,   .f,   ...,   .id = NULL,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_pmap_dfc(   .l,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_walk2(   .x,   .y,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_pwalk(   .l,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )"},{"path":"https://furrr.futureverse.org/dev/reference/future_map2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map over multiple inputs simultaneously via futures — future_map2","text":".x, .y Vectors length. vector length 1 recycled. .f function, formula, vector (necessarily atomic). function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. character vector, numeric vector, list, converted extractor function. Character vectors index name numeric vectors index position; use list index position name different levels. component present, value .default returned. ... Additional arguments passed mapped function. .options future specific options use workers. must result call furrr_options(). .env_globals environment look globals required .x .... Globals required .f looked function environment .f. .progress single logical. progress bar displayed? works multisession, multicore, multiprocess futures. Note multicore/multisession future falls back sequential, progress bar displayed. Warning: .progress argument deprecated removed future version furrr favor using robust progressr package. .id Either string NULL. string, output contain variable name, storing either name (.x named) index (.x unnamed) input. NULL, default, variable created. applies _dfr variant. .l list vectors, data frame. length .l determines number arguments .f called . List names used present.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_map2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map over multiple inputs simultaneously via futures — future_map2","text":"atomic vector, list, data frame, depending suffix. Atomic vectors lists named .x first element .l named. input length 0, output length 0. input length 1, recycled length longest.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_map2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map over multiple inputs simultaneously via futures — future_map2","text":"","code":"plan(multisession, workers = 2)  x <- list(1, 10, 100) y <- list(1, 2, 3) z <- list(5, 50, 500)  future_map2(x, y, ~ .x + .y) #> [[1]] #> [1] 2 #>  #> [[2]] #> [1] 12 #>  #> [[3]] #> [1] 103 #>   # Split into pieces, fit model to each piece, then predict by_cyl <- split(mtcars, mtcars$cyl) mods <- future_map(by_cyl, ~ lm(mpg ~ wt, data = .)) future_map2(mods, by_cyl, predict) #> $`4` #>     Datsun 710      Merc 240D       Merc 230       Fiat 128    Honda Civic  #>       26.47010       21.55719       21.78307       27.14774       30.45125  #> Toyota Corolla  Toyota Corona      Fiat X1-9  Porsche 914-2   Lotus Europa  #>       29.20890       25.65128       28.64420       27.48656       31.02725  #>     Volvo 142E  #>       23.87247  #>  #> $`6` #>      Mazda RX4  Mazda RX4 Wag Hornet 4 Drive        Valiant       Merc 280  #>       21.12497       20.41604       19.47080       18.78968       18.84528  #>      Merc 280C   Ferrari Dino  #>       18.84528       20.70795  #>  #> $`8` #>   Hornet Sportabout          Duster 360          Merc 450SE          Merc 450SL  #>            16.32604            16.04103            14.94481            15.69024  #>         Merc 450SLC  Cadillac Fleetwood Lincoln Continental   Chrysler Imperial  #>            15.58061            12.35773            11.97625            12.14945  #>    Dodge Challenger         AMC Javelin          Camaro Z28    Pontiac Firebird  #>            16.15065            16.33700            15.44907            15.43811  #>      Ford Pantera L       Maserati Bora  #>            16.91800            16.04103  #>   future_pmap(list(x, y, z), sum) #> [[1]] #> [1] 7 #>  #> [[2]] #> [1] 62 #>  #> [[3]] #> [1] 603 #>   # Matching arguments by position future_pmap(list(x, y, z), function(a, b ,c) a / (b + c)) #> [[1]] #> [1] 0.1666667 #>  #> [[2]] #> [1] 0.1923077 #>  #> [[3]] #> [1] 0.1988072 #>   # Vectorizing a function over multiple arguments df <- data.frame(   x = c(\"apple\", \"banana\", \"cherry\"),   pattern = c(\"p\", \"n\", \"h\"),   replacement = c(\"x\", \"f\", \"q\"),   stringsAsFactors = FALSE )  future_pmap(df, gsub) #> [[1]] #> [1] \"axxle\" #>  #> [[2]] #> [1] \"bafafa\" #>  #> [[3]] #> [1] \"cqerry\" #>  future_pmap_chr(df, gsub) #> [1] \"axxle\"  \"bafafa\" \"cqerry\"  # \\dontshow{ # Close open connections for R CMD Check if (!inherits(plan(), \"sequential\")) plan(sequential) # }"},{"path":"https://furrr.futureverse.org/dev/reference/future_map_if.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a function to each element of a vector conditionally via futures — future_map_if","title":"Apply a function to each element of a vector conditionally via futures — future_map_if","text":"functions work exactly purrr::map_if() purrr::map_at(), allow run parallel.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_map_if.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a function to each element of a vector conditionally via futures — future_map_if","text":"","code":"future_map_if(   .x,   .p,   .f,   ...,   .else = NULL,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_map_at(   .x,   .at,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )"},{"path":"https://furrr.futureverse.org/dev/reference/future_map_if.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a function to each element of a vector conditionally via futures — future_map_if","text":".x list atomic vector. .p single predicate function, formula describing predicate function, logical vector length .x. Alternatively, elements .x lists objects, string indicating name logical element inner lists. elements .p evaluates TRUE modified. .f function, formula, vector (necessarily atomic). function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. character vector, numeric vector, list, converted extractor function. Character vectors index name numeric vectors index position; use list index position name different levels. component present, value .default returned. ... Additional arguments passed mapped function. .else function applied elements .x .p returns FALSE. .options future specific options use workers. must result call furrr_options(). .env_globals environment look globals required .x .... Globals required .f looked function environment .f. .progress single logical. progress bar displayed? works multisession, multicore, multiprocess futures. Note multicore/multisession future falls back sequential, progress bar displayed. Warning: .progress argument deprecated removed future version furrr favor using robust progressr package. .character vector names, positive numeric vector positions include, negative numeric vector positions exlude. elements corresponding .modified. tidyselect package installed, can use vars() tidyselect helpers select elements.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_map_if.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a function to each element of a vector conditionally via futures — future_map_if","text":"functions return list length .x elements conditionally transformed.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_map_if.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a function to each element of a vector conditionally via futures — future_map_if","text":"","code":"plan(multisession, workers = 2)  # Modify the even elements future_map_if(1:5, ~.x %% 2 == 0L, ~ -1) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] -1 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] -1 #>  #> [[5]] #> [1] 5 #>   future_map_at(1:5, c(1, 5), ~ -1) #> [[1]] #> [1] -1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  #> [[4]] #> [1] 4 #>  #> [[5]] #> [1] -1 #>  # \\dontshow{ # Close open connections for R CMD Check if (!inherits(plan(), \"sequential\")) plan(sequential) # }"},{"path":"https://furrr.futureverse.org/dev/reference/future_modify.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify elements selectively via futures — future_modify","title":"Modify elements selectively via futures — future_modify","text":"functions work exactly purrr::modify() functions, allow modify parallel.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_modify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify elements selectively via futures — future_modify","text":"","code":"future_modify(   .x,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_modify_at(   .x,   .at,   .f,   ...,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )  future_modify_if(   .x,   .p,   .f,   ...,   .else = NULL,   .options = furrr_options(),   .env_globals = parent.frame(),   .progress = FALSE )"},{"path":"https://furrr.futureverse.org/dev/reference/future_modify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify elements selectively via futures — future_modify","text":".x list atomic vector. .f function, formula, vector (necessarily atomic). function, used . formula, e.g. ~ .x + 2, converted function. three ways refer arguments: single argument function, use . two argument function, use .x .y arguments, use ..1, ..2, ..3 etc syntax allows create compact anonymous functions. character vector, numeric vector, list, converted extractor function. Character vectors index name numeric vectors index position; use list index position name different levels. component present, value .default returned. ... Additional arguments passed mapped function. .options future specific options use workers. must result call furrr_options(). .env_globals environment look globals required .x .... Globals required .f looked function environment .f. .progress single logical. progress bar displayed? works multisession, multicore, multiprocess futures. Note multicore/multisession future falls back sequential, progress bar displayed. Warning: .progress argument deprecated removed future version furrr favor using robust progressr package. .character vector names, positive numeric vector positions include, negative numeric vector positions exlude. elements corresponding .modified. tidyselect package installed, can use vars() tidyselect helpers select elements. .p single predicate function, formula describing predicate function, logical vector length .x. Alternatively, elements .x lists objects, string indicating name logical element inner lists. elements .p evaluates TRUE modified. .else function applied elements .x .p returns FALSE.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_modify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modify elements selectively via futures — future_modify","text":"object class .x","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_modify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Modify elements selectively via futures — future_modify","text":"purrr: Since transformation can alter structure input; responsibility ensure transformation produces valid output. example, modifying data frame, .f must preserve length input.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_modify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modify elements selectively via futures — future_modify","text":"","code":"library(magrittr) plan(multisession, workers = 2)  # Convert each col to character, in parallel future_modify(mtcars, as.character) #>                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb #> Mazda RX4             21   6   160 110  3.9  2.62 16.46  0  1    4    4 #> Mazda RX4 Wag         21   6   160 110  3.9 2.875 17.02  0  1    4    4 #> Datsun 710          22.8   4   108  93 3.85  2.32 18.61  1  1    4    1 #> Hornet 4 Drive      21.4   6   258 110 3.08 3.215 19.44  1  0    3    1 #> Hornet Sportabout   18.7   8   360 175 3.15  3.44 17.02  0  0    3    2 #> Valiant             18.1   6   225 105 2.76  3.46 20.22  1  0    3    1 #> Duster 360          14.3   8   360 245 3.21  3.57 15.84  0  0    3    4 #> Merc 240D           24.4   4 146.7  62 3.69  3.19    20  1  0    4    2 #> Merc 230            22.8   4 140.8  95 3.92  3.15  22.9  1  0    4    2 #> Merc 280            19.2   6 167.6 123 3.92  3.44  18.3  1  0    4    4 #> Merc 280C           17.8   6 167.6 123 3.92  3.44  18.9  1  0    4    4 #> Merc 450SE          16.4   8 275.8 180 3.07  4.07  17.4  0  0    3    3 #> Merc 450SL          17.3   8 275.8 180 3.07  3.73  17.6  0  0    3    3 #> Merc 450SLC         15.2   8 275.8 180 3.07  3.78    18  0  0    3    3 #> Cadillac Fleetwood  10.4   8   472 205 2.93  5.25 17.98  0  0    3    4 #> Lincoln Continental 10.4   8   460 215    3 5.424 17.82  0  0    3    4 #> Chrysler Imperial   14.7   8   440 230 3.23 5.345 17.42  0  0    3    4 #> Fiat 128            32.4   4  78.7  66 4.08   2.2 19.47  1  1    4    1 #> Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2 #> Toyota Corolla      33.9   4  71.1  65 4.22 1.835  19.9  1  1    4    1 #> Toyota Corona       21.5   4 120.1  97  3.7 2.465 20.01  1  0    3    1 #> Dodge Challenger    15.5   8   318 150 2.76  3.52 16.87  0  0    3    2 #> AMC Javelin         15.2   8   304 150 3.15 3.435  17.3  0  0    3    2 #> Camaro Z28          13.3   8   350 245 3.73  3.84 15.41  0  0    3    4 #> Pontiac Firebird    19.2   8   400 175 3.08 3.845 17.05  0  0    3    2 #> Fiat X1-9           27.3   4    79  66 4.08 1.935  18.9  1  1    4    1 #> Porsche 914-2         26   4 120.3  91 4.43  2.14  16.7  0  1    5    2 #> Lotus Europa        30.4   4  95.1 113 3.77 1.513  16.9  1  1    5    2 #> Ford Pantera L      15.8   8   351 264 4.22  3.17  14.5  0  1    5    4 #> Ferrari Dino        19.7   6   145 175 3.62  2.77  15.5  0  1    5    6 #> Maserati Bora         15   8   301 335 3.54  3.57  14.6  0  1    5    8 #> Volvo 142E          21.4   4   121 109 4.11  2.78  18.6  1  1    4    2  iris %>%  future_modify_if(is.factor, as.character) %>%  str() #> 'data.frame':\t150 obs. of  5 variables: #>  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... #>  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... #>  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... #>  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... #>  $ Species     : chr  \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...  mtcars %>%   future_modify_at(c(1, 4, 5), as.character) %>%   str() #> 'data.frame':\t32 obs. of  11 variables: #>  $ mpg : chr  \"21\" \"21\" \"22.8\" \"21.4\" ... #>  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ... #>  $ disp: num  160 160 108 258 360 ... #>  $ hp  : chr  \"110\" \"110\" \"93\" \"110\" ... #>  $ drat: chr  \"3.9\" \"3.9\" \"3.85\" \"3.08\" ... #>  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ... #>  $ qsec: num  16.5 17 18.6 19.4 17 ... #>  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ... #>  $ am  : num  1 1 1 0 0 0 0 0 0 0 ... #>  $ gear: num  4 4 4 3 3 3 3 4 4 4 ... #>  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...  # \\dontshow{ # Close open connections for R CMD Check if (!inherits(plan(), \"sequential\")) plan(sequential) # }"},{"path":"https://furrr.futureverse.org/dev/reference/future_options.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated furrr options — future_options","title":"Deprecated furrr options — future_options","text":"furrr 0.3.0, future_options() defunct favor furrr_options().","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_options.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated furrr options — future_options","text":"","code":"future_options(globals = TRUE, packages = NULL, seed = FALSE, scheduling = 1)"},{"path":"https://furrr.futureverse.org/dev/reference/future_options.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deprecated furrr options — future_options","text":"globals logical, character vector, named list, NULL controlling globals handled. details, see Global variables section . packages character vector, NULL. supplied, specifies packages guaranteed attached R environment future evaluated. seed logical, integer length 1 7, list length(.x) pre-generated random seeds, NULL. details, see Reproducible random number generation (RNG) section . scheduling single integer, logical, Inf. argument controls average number futures (\"chunks\") per worker. 0, single future used process elements .x. 1 TRUE, one future per worker used. 2, worker process two futures (provided enough elements .x). Inf FALSE, one future per element .x used. argument used chunk_size NULL.","code":""},{"path":"https://furrr.futureverse.org/dev/reference/future_options.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deprecated furrr options — future_options","text":"","code":"try(future_options()) #> Error : `future_options()` was deprecated in furrr 0.3.0 and is now defunct. #> Please use `furrr_options()` instead."},{"path":"https://furrr.futureverse.org/dev/news/index.html","id":"furrr-development-version","dir":"Changelog","previous_headings":"","what":"furrr (development version)","title":"furrr (development version)","text":"Redocumented package roxygen2 7.2.1 fix invalid HTML5 issues (#242).","code":""},{"path":"https://furrr.futureverse.org/dev/news/index.html","id":"furrr-030","dir":"Changelog","previous_headings":"","what":"furrr 0.3.0","title":"furrr 0.3.0","text":"CRAN release: 2022-05-04","code":""},{"path":"https://furrr.futureverse.org/dev/news/index.html","id":"breaking-changes-0-3-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"furrr 0.3.0","text":"future_options() now defunct removed next minor release furrr. Please use furrr_options() instead (#137). lazy argument furrr_options() completely removed. argument effect, futures always resolved corresponding furrr function returns (#222).","code":""},{"path":"https://furrr.futureverse.org/dev/news/index.html","id":"features--fixes-0-3-0","dir":"Changelog","previous_headings":"","what":"Features / Fixes","title":"furrr 0.3.0","text":"future_walk() walk functions now avoid sending results calling .f back main process (#205). conditions argument furrr_options() now supports selectively ignoring conditions exclude attribute. See ?furrr_options information (#181). Standard output now dropped future results returned main process (#216). Condition objects now dropped future results returned main process (#216). Unskipped test now upstream bug future fixed (#218, HenrikBengtsson/future.apply#10). Removed ellipsis favor equivalent functions rlang (#219). Removed multisession test related whether attempt made load furrr workers (#217). Updated snapshot tests related testthat prints condition details (#213).","code":""},{"path":"https://furrr.futureverse.org/dev/news/index.html","id":"version-requirements-0-3-0","dir":"Changelog","previous_headings":"","what":"Version requirements","title":"furrr 0.3.0","text":"furrr now requires R >=3.4.0, line tidyverse. lifecycle >=1.0.1, rlang >=1.0.2, purrr >=0.3.4, vctrs >=0.4.1, globals >=0.14.0, future >=1.25.0 now required (#214).","code":""},{"path":"https://furrr.futureverse.org/dev/news/index.html","id":"furrr-023","dir":"Changelog","previous_headings":"","what":"furrr 0.2.3","title":"furrr 0.2.3","text":"CRAN release: 2021-06-25 Preemptively updated tests related upcoming changes testthat (#196). Updated snapshot tests failing CI related changes lifecycle 1.0.0 (#193).","code":""},{"path":"https://furrr.futureverse.org/dev/news/index.html","id":"furrr-022","dir":"Changelog","previous_headings":"","what":"furrr 0.2.2","title":"furrr 0.2.2","text":"CRAN release: 2021-01-29 Updated test fix issue upcoming lifecycle 1.0.0.","code":""},{"path":"https://furrr.futureverse.org/dev/news/index.html","id":"furrr-021","dir":"Changelog","previous_headings":"","what":"furrr 0.2.1","title":"furrr 0.2.1","text":"CRAN release: 2020-10-21 Updated documentation examples explicitly set seed workers random numbers generated (#175). Removed internal call future:::supportsMulticore() since longer internal (#174).","code":""},{"path":"https://furrr.futureverse.org/dev/news/index.html","id":"furrr-020","dir":"Changelog","previous_headings":"","what":"furrr 0.2.0","title":"furrr 0.2.0","text":"CRAN release: 2020-10-12","code":""},{"path":"https://furrr.futureverse.org/dev/news/index.html","id":"breaking-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"Breaking changes:","title":"furrr 0.2.0","text":"furrr functions now enforce tidyverse recycling rules (example, .x .y future_map2()). Previously mostly case, except size zero input. Recycling input size 0 input size >1 longer recycles size 0, instead error. purrr begin well next major release (#134). future_options() deprecated favor furrr_options(). Calling future_options() still work, trigger per session warning eventually removed. change made free function name case future package ever wants use . future version furrr, .progress argument deprecated removed favor progressr package. progress bar yet removed furrr 0.2.0, however encourage please start using progressr possible. uses much robust idea, integrated future way can relay near real-time progress updates sequential, multisession, even cluster futures (meaning remote connections can return live updates). Multicore support come point well. said, aware relatively new package API still stabilizing. people use , place future ecosystem become clearer, tighter integration furrr likely possible.","code":""},{"path":"https://furrr.futureverse.org/dev/news/index.html","id":"features--fixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Features / Fixes:","title":"furrr 0.2.0","text":"New pkgdown article using furrr progressr generating progress updates. New pkgdown article discussing alternative strategy automatic globals detection using carrier package. New pkgdown article discussing furrr “chunks” input send workers. New pkgdown article common gotchas using furrr. New pkgdown article detailing use furrr remote AWS EC2 connections. future_walk() friends added mirror purrr::walk(). furrr_options() now variety new arguments fine tuning furrr. based advancements made future future.apply. important chunk_size, can used alternative scheduling determine break .x chunks send workers. See ?furrr_options full details. future_pmap() variants now propagate names first element .l onto output (#116). future_pmap() variants now work empty list() input (#135). future_modify(), future_modify_if() future_modify_at() brought date changes purrr 0.3.0 non-parallel equivalents. Specifically, now wrap [[<- return type input input atomic vector (#119). future_map_if() future_modify_if() gained .else argument added purrr’s map_if() modify_if() purrr 0.3.0 (#132). *_raw() variants purrr added, future_map_raw() (#122). furrr functions gained new argument, .env_globals, determines environment globals .x ... looked . defaults caller environment, different previously used, correct edge cases. time, touch argument. Additionally, globals .f now looked function environment .f (HenrikBengtsson/future.apply#62, #153). future specific global option future.globals.maxSize now scales number elements .x get exported worker. helps prevent false positives exporting objects large, approach taken future.apply (#113). .x now searched globals. globals found slice .x corresponds worker X exported worker X. relevant .x , say, list functions set globals (#16). progress bar furrr creates now outputs stderr rather stdout. progress bar now enabled multisession, multicore, multiprocess strategies. never worked sequential futures cluster futures using remote connections, .progress now forced false cases. future_invoke_map() variants marked retired match purrr::invoke_map(). internals furrr overhauled unify implementations future_map(), future_map2(), future_pmap() variants. make furrr much easier maintain going forward (#44). MIT license now used.","code":""},{"path":"https://furrr.futureverse.org/dev/news/index.html","id":"version-requirements-0-2-0","dir":"Changelog","previous_headings":"","what":"Version requirements:","title":"furrr 0.2.0","text":"rlang >= 0.3.0 now required ensure rlang ~ serializable. hacks furrr tried work around removed (#123). future >= 1.19.1 now required able use future::value() instead soon deprecated future::values() access bug fixes (#108). purrr >= 0.3.0 now required gain access various new features breaking changes. example, map_if() gained .else argument, added future_map_if(). globals >= 0.13.1 now required substantial new speed boosts related searching global variables, gain access bug fixes.","code":""},{"path":"https://furrr.futureverse.org/dev/news/index.html","id":"furrr-010","dir":"Changelog","previous_headings":"","what":"furrr 0.1.0","title":"furrr 0.1.0","text":"CRAN release: 2018-05-16 Features: future_pmap_*() functions added mirror pmap(). future.* arguments function replaced overarching .options argument. Use future_options() create set options suitable passed .options. change streamlines interface greatly, simplifies documentation (#8, @hadley). future_invoke_map_*() functions added mirror invoke_map(). documentation examples added. Added ability use progress bar .progress = TRUE multicore, multiprocess, multisession plan()s. Bug Fixes: Fixed bug using ~ inside mutate() + map() combination. Added missed future_imap_int().","code":""},{"path":"https://furrr.futureverse.org/dev/news/index.html","id":"furrr-000","dir":"Changelog","previous_headings":"","what":"furrr 0.0.0","title":"furrr 0.0.0","text":"Original GitHub release furrr 2018-04-13.","code":""}]
